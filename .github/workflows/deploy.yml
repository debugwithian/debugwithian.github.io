name: ðŸš€ Auto Deploy to AWS with AI Code Review (Groq)

on:
  pull_request:
    branches:
      - prod_v2
    types: [opened, synchronize, reopened]
  push:
    branches:
      - prod_v2
  workflow_dispatch:

jobs:
  ai_code_review:
    name: ðŸ¤– AI Code Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    outputs:
      review_status: ${{ steps.set_review_status.outputs.review_status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq curl git

      - name: Validate secrets
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          : "${GROQ_API_KEY:?GROQ_API_KEY is not set}"
          : "${PAT_TOKEN:?PAT_TOKEN is not set}"
          echo "âœ… Secrets validated."

      - name: Generate Git Diff for PR branch
        id: generate_diff
        run: |
          set -e
          git fetch origin prod_v2
          git fetch origin +refs/pull/${{ github.event.pull_request.number }}/head:pr_branch
          git checkout pr_branch
          BASE=$(git merge-base HEAD origin/prod_v2)
          if ! git diff $BASE HEAD --quiet; then
            git diff $BASE HEAD > diff.txt
            echo "diff_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "No issues detected." > ai_review_output.txt
            echo "diff_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run AI Code Review (Groq)
        id: run_ai
        if: steps.generate_diff.outputs.diff_exists == 'true'
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          set -e
          DIFF=$(<diff.txt)
          PROMPT="You are a strict senior engineer. Avoid checking YAML file. Review the following git diff for logic, security, syntax, performance. Return Markdown with a final status: PASSED, NEEDS IMPROVEMENTS, or CRITICAL.\n\n$DIFF"
          AI_COMMENT=$(curl -sS --fail https://api.groq.com/openai/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $GROQ_API_KEY" \
            -d "$(jq -n --arg prompt "$PROMPT" '{model: "llama-3.1-8b-instant", messages: [{role: "user", content: $prompt}]}')" \
            | jq -r '.choices[0].message.content // "No issues detected."')
          printf "%s" "$AI_COMMENT" > ai_review_output.txt

      - name: Analyze AI Review
        id: set_review_status
        run: |
          set -e
          AI_COMMENT=$(<ai_review_output.txt)
          STATUS="IMPROVEMENTS"
          if echo "$AI_COMMENT" | grep -iq "critical"; then
            if echo "$AI_COMMENT" | grep -iqE "no critical|not critical"; then
              STATUS="IMPROVEMENTS"
            else
              STATUS="CRITICAL_ISSUE"
            fi
          elif echo "$AI_COMMENT" | grep -iq "passed"; then
            STATUS="PASSED"
          fi
          echo "$AI_COMMENT" > ai_review_status.txt
          echo "review_status=$STATUS" >> "$GITHUB_OUTPUT"

      - name: Post Review to PR
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          COMMENT=$(<ai_review_status.txt)
          JSON=$(jq -Rs --arg c "$COMMENT" '{body: $c}')
          curl -sS -X POST \
               -H "Authorization: token $PAT_TOKEN" \
               -H "Content-Type: application/json" \
               -d "$JSON" \
               "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments"

      - name: Fail on Critical
        if: steps.set_review_status.outputs.review_status == 'CRITICAL_ISSUE'
        run: |
          echo "âŒ Critical issues found. Blocking."
          exit 1

  deploy_dynamic_env:
    name: ðŸŒ Deploy Preview Environment (Docker)
    runs-on: ubuntu-latest
    needs: ai_code_review
    if: github.event_name == 'pull_request' && needs.ai_code_review.outputs.review_status != 'CRITICAL_ISSUE'

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Add SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 3.232.21.89 >> ~/.ssh/known_hosts

      - name: Deploy branch via Docker
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 "BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF##refs/heads/}} bash -s" <<'ENDSSH'
            set -euo pipefail

            # --- Inputs from environment ---
            # BRANCH is injected from the ssh command line
            # PAT_TOKEN should be available in the remote environment via the action secrets or env
            SAFE_BRANCH=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9]/-/g' | sed 's/^-*//;s/-*$//')
            DOMAIN="$SAFE_BRANCH.debugwithian.com"
            IMAGE_NAME="preview-$SAFE_BRANCH"

            # --- Find a free port on the host (8090-8500) ---
            # Use ss to list listening tcp ports (robust)
            sudo mkdir -p /var/www/letsencrypt
            sudo chmod 755 /var/www/letsencrypt

            USED_PORTS=$(ss -ltn 2>/dev/null | awk 'NR>1 {print $4}' | awk -F':' '{print $NF}' | sort -u || true)
            PORT=$(comm -23 <(seq 8090 8500) <(echo "$USED_PORTS") | head -n1 || true)
            if [ -z "$PORT" ]; then
              echo "âŒ No free port found in range 8090-8500"
              exit 1
            fi

            echo "Using port: $PORT"

            # --- Clone branch (use PAT correctly) ---
            TMPDIR="/tmp/$SAFE_BRANCH"
            rm -rf "$TMPDIR"
            # Ensure PAT_TOKEN is present
            if [ -z "${PAT_TOKEN:-}" ]; then
              echo "âŒ PAT_TOKEN is not set on the remote. Aborting."
              exit 1
            fi

            git clone --depth 1 --branch "$BRANCH" "https://${PAT_TOKEN}@github.com/debugwithian/debugwithian.github.io.git" "$TMPDIR"
            cd "$TMPDIR"

            # --- Build Docker image (best-effort) ---
            docker build -t "$IMAGE_NAME" . || true

            # --- Stop old container if exists ---
            docker rm -f "$IMAGE_NAME" 2>/dev/null || true

            # --- Run new container ---
            # Map host $PORT to container 3000. Use restart=unless-stopped so it survives reboots.
            docker run -d --name "$IMAGE_NAME" --restart unless-stopped -p "$PORT":3000 -v "$TMPDIR":/app -w /app node:20-alpine sh -c "npm ci --prefer-offline --no-audit --progress=false && npm start" || {
              echo "âŒ Docker failed to start $IMAGE_NAME"
              exit 1
            }

            # --- Nginx config paths ---
            NGINX_FILE="/etc/nginx/sites-available/$SAFE_BRANCH.conf"
            WWW_LETSENCRYPT="/var/www/letsencrypt"

            # --- Write an HTTP-only config that also serves ACME challenges ---
            HTTP_CONFIG="server {
                listen 80;
                listen [::]:80;
                server_name $DOMAIN;

                # Serve Let's Encrypt HTTP-01 challenges from the well-known directory
                location /.well-known/acme-challenge/ {
                    root $WWW_LETSENCRYPT;
                    try_files \$uri =404;
                }

                # Proxy everything else to the Docker app
                location / {
                    proxy_pass http://127.0.0.1:$PORT;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_http_version 1.1;
                    proxy_set_header Connection "";
                }
            }"

            echo "$HTTP_CONFIG" | sudo tee "$NGINX_FILE" > /dev/null
            sudo ln -sf "$NGINX_FILE" /etc/nginx/sites-enabled/
            sudo nginx -t
            sudo systemctl reload nginx

            # --- Obtain or renew certificate using certbot webroot ---
            # Ensure webroot exists and permissions are correct
            sudo mkdir -p "$WWW_LETSENCRYPT"
            sudo chown -R www-data:www-data "$WWW_LETSENCRYPT" || true
            sudo chmod 755 "$WWW_LETSENCRYPT"

            if [ ! -d "/etc/letsencrypt/live/$DOMAIN" ]; then
              echo "Requesting certificate for $DOMAIN (this may fail if DNS is not pointed yet)..."
              sudo certbot certonly --webroot -w "$WWW_LETSENCRYPT" --non-interactive --agree-tos -m ddiamanterbitwilio@gmail.com -d "$DOMAIN" || true
            else
              echo "Certificate already exists for $DOMAIN, skipping certbot issuance."
            fi

            # --- If cert exists, write final HTTPS-enabled config (overwrite) ---
            if [ -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ] && [ -f "/etc/letsencrypt/live/$DOMAIN/privkey.pem" ]; then
              SSL_CONFIG="server {
                  listen 80;
                  listen [::]:80;
                  server_name $DOMAIN;

                  # Redirect HTTP to HTTPS (preserve challenge path)
                  location /.well-known/acme-challenge/ {
                      root $WWW_LETSENCRYPT;
                      try_files \$uri =404;
                  }

                  location / {
                      return 301 https://\$host\$request_uri;
                  }
              }

              server {
                  listen 443 ssl http2;
                  listen [::]:443 ssl http2;
                  server_name $DOMAIN;

                  ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
                  ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
                  ssl_session_cache shared:SSL:10m;
                  ssl_session_timeout 10m;

                  # Proxy to Docker app
                  location / {
                      proxy_pass http://127.0.0.1:$PORT;
                      proxy_set_header Host \$host;
                      proxy_set_header X-Real-IP \$remote_addr;
                      proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto \$scheme;
                      proxy_http_version 1.1;
                      proxy_set_header Connection "";
                  }
              }"

              echo "$SSL_CONFIG" | sudo tee "$NGINX_FILE" > /dev/null
              sudo nginx -t
              sudo systemctl reload nginx

              echo "âœ… Docker preview for $BRANCH deployed at https://$DOMAIN on port $PORT"
            else
              echo "âš ï¸ Certificate not available for $DOMAIN. HTTP preview available at http://$DOMAIN (port forwarded to $PORT)."
              echo "If DNS is not yet pointed to this host, make sure the domain resolves to this server before running certbot."
              echo "You can retry certbot manually: sudo certbot certonly --webroot -w $WWW_LETSENCRYPT -d $DOMAIN"
              echo "âœ… Docker preview for $BRANCH deployed at http://$DOMAIN on port $PORT"
            fi
          ENDSSH


  deploy:
    name: ðŸš€ Deploy to AWS (prod_v2)
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/prod_v2'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Add SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 3.232.21.89 >> ~/.ssh/known_hosts

      - name: Deploy and restart app on AWS (PM2)
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 '
            set -e
            cd /home/ubuntu
            git fetch origin prod_v2
            git reset --hard origin/prod_v2
            npm install
            pm2 restart all
            pm2 save
            echo "âœ… Production deployment completed successfully"
          '
