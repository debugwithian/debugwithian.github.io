name: Full Automation Pipeline (AI Code Review, Testing Environment Created, Auto Deployment)

on:
  pull_request:
    branches:
      - prod_v2
    types: [opened, synchronize, reopened, closed]
  push:
    branches:
      - prod_v2
  workflow_dispatch:

jobs:
  ai_code_review:
    name: ðŸ¤– AI Code Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    outputs:
      review_status: ${{ steps.set_review_status.outputs.review_status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Validate secrets
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          : "${GROQ_API_KEY:?GROQ_API_KEY is not set}"
          : "${PAT_TOKEN:?PAT_TOKEN is not set}"
          echo "âœ… Secrets validated."

      - name: Generate Git Diff for PR branch
        id: generate_diff
        run: |
          set -e
          git fetch origin prod_v2
          git fetch origin +refs/pull/${{ github.event.pull_request.number }}/head:pr_branch
          git checkout pr_branch
          BASE=$(git merge-base HEAD origin/prod_v2)
          if ! git diff $BASE HEAD --quiet; then
            git diff $BASE HEAD > diff.txt
            echo "diff_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "No issues detected." > ai_review_output.txt
            echo "diff_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run AI Code Review
        id: run_ai
        if: steps.generate_diff.outputs.diff_exists == 'true'
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          set -e
          DIFF=$(<diff.txt)
          PROMPT="You are a strict senior engineer. Review the following git diff for logic, security, syntax, performance. Ignore YAML updates. Return Markdown with a final status: PASSED, NEEDS IMPROVEMENTS, or CRITICAL.\n\n$DIFF"
          AI_COMMENT=$(curl -sS --fail https://api.groq.com/openai/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $GROQ_API_KEY" \
            -d "$(jq -n --arg prompt "$PROMPT" '{model: "llama-3.1-8b-instant", messages: [{role: "user", content: $prompt}]}')" \
            | jq -r '.choices[0].message.content // "No issues detected."')
          printf "%s" "$AI_COMMENT" > ai_review_output.txt

      - name: Analyze AI Review
        id: set_review_status
        run: |
          set -e
          AI_COMMENT=$(<ai_review_output.txt)
          STATUS="IMPROVEMENTS"
          if echo "$AI_COMMENT" | grep -iq "critical"; then
            if echo "$AI_COMMENT" | grep -iqE "no critical|not critical"; then
              STATUS="IMPROVEMENTS"
            else
              STATUS="CRITICAL_ISSUE"
            fi
          elif echo "$AI_COMMENT" | grep -iq "passed"; then
            STATUS="PASSED"
          fi
          echo "$AI_COMMENT" > ai_review_status.txt
          echo "review_status=$STATUS" >> "$GITHUB_OUTPUT"

      - name: Post Review to PR
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          COMMENT=$(<ai_review_status.txt)
          JSON=$(jq -Rs --arg c "$COMMENT" '{body: $c}')
          curl -sS -X POST \
               -H "Authorization: token $PAT_TOKEN" \
               -H "Content-Type: application/json" \
               -d "$JSON" \
               "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments"

      - name: Fail on Critical
        if: steps.set_review_status.outputs.review_status == 'CRITICAL_ISSUE'
        run: |
          echo "âŒ Critical issues found. Blocking."
          exit 1

  deploy_dynamic_env:
    name: ðŸŒ Create Testing Environment
    runs-on: ubuntu-latest
    needs: ai_code_review
    if: github.event_name == 'pull_request' && needs.ai_code_review.outputs.review_status != 'CRITICAL_ISSUE'

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Add SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 3.232.21.89 >> ~/.ssh/known_hosts

      - name: Deploy Testing Environment
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 "BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF##refs/heads/}} bash -s" <<'ENDSSH'
            set -e

            SAFE_BRANCH=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9]/-/g')
            DOMAIN="$SAFE_BRANCH.debugwithian.com"
            APP_DIR="/var/www/$DOMAIN/app"
            WEBROOT="/var/www/$DOMAIN"
            NGINX_FILE="/etc/nginx/sites-available/$BRANCH.conf"

            # 1ï¸âƒ£ Find a free port for this branch
            PORT=$(seq 8090 8500 | grep -v -f <(sudo lsof -i -P -n | awk '{print $9}') | head -n1)
            echo "Using port: $PORT for branch: $BRANCH"

            # 2ï¸âƒ£ Ensure webroot exists and is owned by ubuntu (fully deletable)
            sudo mkdir -p "$WEBROOT"
            sudo chown -R ubuntu:ubuntu "$WEBROOT"
            sudo chmod 755 "$WEBROOT"
            echo "ok" | tee "$WEBROOT/index.html" > /dev/null

            # 3ï¸âƒ£ Clone or pull the branch from GitHub
            if [ ! -d "$APP_DIR/.git" ]; then
                echo "Cloning branch $BRANCH into $APP_DIR..."
                git clone --branch "$BRANCH" git@github.com:$PAT_TOKEN/${{ github.repository }}.git "$APP_DIR"
            else
                echo "Pulling latest changes for branch $BRANCH..."
                cd "$APP_DIR"
                git fetch origin "$BRANCH"
                git reset --hard "origin/$BRANCH"
            fi

            # 4ï¸âƒ£ Install dependencies (example: Node.js)
            cd "$APP_DIR"
            if [ -f "package.json" ]; then
                echo "Installing Node.js dependencies..."
                npm install
            fi

            # 5ï¸âƒ£ Start the app in background on the free port (example: Node.js)
            if lsof -i:$PORT | grep LISTEN; then
                echo "Killing previous process on port $PORT..."
                sudo fuser -k $PORT/tcp
            fi
            echo "Starting app on port $PORT..."
            nohup npm start -- --port $PORT > "$APP_DIR/nohup.log" 2>&1 &

            # 6ï¸âƒ£ Temporary HTTP-only Nginx config
            NGINX_TEMP_CONFIG="server {
                listen 80;
                listen [::]:80;
                server_name $DOMAIN;
                root $WEBROOT;
                location / { try_files \$uri \$uri/ =404; }
            }"

            if [ ! -f "$NGINX_FILE" ]; then
                echo "Creating temporary HTTP-only config for $DOMAIN..."
                echo "$NGINX_TEMP_CONFIG" | sudo tee "$NGINX_FILE" > /dev/null
                sudo ln -sf "$NGINX_FILE" /etc/nginx/sites-enabled/
            fi

            # Test and reload Nginx
            sudo nginx -t
            sudo systemctl reload nginx

            # 7ï¸âƒ£ Request SSL certificate using webroot
            if [ ! -d "/etc/letsencrypt/live/$DOMAIN" ]; then
                echo "SSL certificate not found. Requesting cert for $DOMAIN..."
                sudo certbot certonly --webroot -w "$WEBROOT" -d "$DOMAIN" --non-interactive --agree-tos -m ddiamanterbitwilio@gmail.com || true
            fi

            # 8ï¸âƒ£ Final HTTPS + proxy config
            NGINX_FINAL_CONFIG="server {
                listen 80;
                listen [::]:80;
                server_name $DOMAIN;
                return 301 https://\$host\$request_uri;
            }
            server {
                listen 443 ssl http2;
                listen [::]:443 ssl http2;
                server_name $DOMAIN;

                ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
                include /etc/letsencrypt/options-ssl-nginx.conf;
                ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

                location / {
                    proxy_pass http://localhost:$PORT;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
            }"

            if [ -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]; then
                echo "Writing final HTTPS proxy config for $DOMAIN..."
                echo "$NGINX_FINAL_CONFIG" | sudo tee "$NGINX_FILE" > /dev/null
                sudo ln -sf "$NGINX_FILE" /etc/nginx/sites-enabled/
            else
                echo "SSL cert for $DOMAIN still missing. Keeping temporary HTTP-only config."
            fi

            # 9ï¸âƒ£ Test and reload Nginx safely
            sudo nginx -t && sudo systemctl reload nginx

            echo "âœ… Branch $BRANCH deployed at https://$DOMAIN on port $PORT"
          ENDSSH

     
  deploy:
    name: ðŸš€ Deploy to AWS (prod_v2)
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/prod_v2'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Add SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 3.232.21.89 >> ~/.ssh/known_hosts

      - name: Deploy and restart app on AWS
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 '
            set -e
            cd /home/ubuntu
            git fetch origin prod_v2
            git reset --hard origin/prod_v2
            npm install
            pm2 restart all
            pm2 save
            echo "âœ… Production deployment completed successfully"
          '

      - name: Delete Testing Environment (Last Merged Branch)
        run: |
          # Ensure full history is fetched
          git fetch --unshallow || true
          git fetch origin prod_v2 --tags --prune

          # Get last merge commit on prod_v2
          LAST_MERGE_COMMIT=$(git log origin/prod_v2 --merges -1 --pretty=%H)
          echo "Last merge commit: $LAST_MERGE_COMMIT"

          if [ -z "$LAST_MERGE_COMMIT" ]; then
            echo "No merge commit found on prod_v2. Skipping cleanup."
            exit 0
          fi

          # Get the branch that was merged
          LAST_MERGED_BRANCH=$(git log -1 --pretty=%P $LAST_MERGE_COMMIT \
            | xargs -n1 git name-rev --name-only \
            | grep -v "prod_v2" \
            | sed "s#^remotes/origin/##")
          echo "Last merged branch: $LAST_MERGED_BRANCH"

          if [ -z "$LAST_MERGED_BRANCH" ]; then
            echo "No merged branch found. Skipping cleanup."
            exit 0
          fi

          # SSH cleanup
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 "
            set -e
            BRANCH='$LAST_MERGED_BRANCH'
            SAFE_BRANCH=\$(echo \"\$BRANCH\" | sed 's/[^a-zA-Z0-9]/-/g')
            DOMAIN=\"\$SAFE_BRANCH.debugwithian.com\"
            WEBROOT=\"/var/www/\$DOMAIN\"
            APP_DIR=\"/var/www/\$DOMAIN/app\"
            NGINX_FILE=\"/etc/nginx/sites-available/\$BRANCH.conf\"

            echo 'ðŸ§¹ Cleaning preview environment for branch: '\$BRANCH
            echo 'Domain: '\$DOMAIN

            pkill -f \"\$APP_DIR\" || true
            sudo rm -rf \"\$WEBROOT\"
            sudo rm -f \"\$NGINX_FILE\" \"/etc/nginx/sites-enabled/\$BRANCH.conf\"
            sudo certbot delete --cert-name \"\$DOMAIN\" --non-interactive || true
            sudo nginx -t && sudo systemctl reload nginx
            pm2 restart all
            pm2 save
            echo \"ðŸŽ‰ Successfully cleaned dynamic environment: https://\$DOMAIN\"
          "
