name: ðŸš€ Auto Deploy to AWS with AI Code Review (Groq)

on:
  pull_request:
    branches:
      - prod_v2
    types: [opened, synchronize, reopened]
  push:
    branches:
      - prod_v2
  workflow_dispatch:

jobs:
  ai_code_review:
    name: ðŸ¤– AI Code Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    outputs:
      review_status: ${{ steps.set_review_status.outputs.review_status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq curl git

      - name: Validate secrets
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          : "${GROQ_API_KEY:?GROQ_API_KEY is not set}"
          : "${PAT_TOKEN:?PAT_TOKEN is not set}"
          echo "âœ… Secrets validated."

      - name: Generate Git Diff for PR branch
        id: generate_diff
        run: |
          set -e
          git fetch origin prod_v2
          git fetch origin +refs/pull/${{ github.event.pull_request.number }}/head:pr_branch
          git checkout pr_branch
          BASE=$(git merge-base HEAD origin/prod_v2)
          if ! git diff $BASE HEAD --quiet; then
            git diff $BASE HEAD > diff.txt
            echo "diff_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "No issues detected." > ai_review_output.txt
            echo "diff_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run AI Code Review (Groq)
        id: run_ai
        if: steps.generate_diff.outputs.diff_exists == 'true'
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          set -e
          DIFF=$(<diff.txt)
          PROMPT="You are a strict senior engineer. Avoid checking deploy.YAML file. Review the following git diff for logic, security, syntax, performance. Return Markdown with a final status: PASSED, NEEDS IMPROVEMENTS, or CRITICAL.\n\n$DIFF"
          AI_COMMENT=$(curl -sS --fail https://api.groq.com/openai/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $GROQ_API_KEY" \
            -d "$(jq -n --arg prompt "$PROMPT" '{model: "llama-3.1-8b-instant", messages: [{role: "user", content: $prompt}]}')" \
            | jq -r '.choices[0].message.content // "No issues detected."')
          printf "%s" "$AI_COMMENT" > ai_review_output.txt

      - name: Analyze AI Review
        id: set_review_status
        run: |
          set -e
          AI_COMMENT=$(<ai_review_output.txt)
          STATUS="IMPROVEMENTS"
          if echo "$AI_COMMENT" | grep -iq "critical"; then
            if echo "$AI_COMMENT" | grep -iqE "no critical|not critical"; then
              STATUS="IMPROVEMENTS"
            else
              STATUS="CRITICAL_ISSUE"
            fi
          elif echo "$AI_COMMENT" | grep -iq "passed"; then
            STATUS="PASSED"
          fi
          echo "$AI_COMMENT" > ai_review_status.txt
          echo "review_status=$STATUS" >> "$GITHUB_OUTPUT"

      - name: Post Review to PR
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          COMMENT=$(<ai_review_status.txt)
          JSON=$(jq -Rs --arg c "$COMMENT" '{body: $c}')
          curl -sS -X POST \
               -H "Authorization: token $PAT_TOKEN" \
               -H "Content-Type: application/json" \
               -d "$JSON" \
               "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments"

      - name: Fail on Critical
        if: steps.set_review_status.outputs.review_status == 'CRITICAL_ISSUE'
        run: |
          echo "âŒ Critical issues found. Blocking."
          exit 1

  deploy_dynamic_env:
    name: ðŸŒ Deploy Preview Environment (Docker)
    runs-on: ubuntu-latest
    needs: ai_code_review
    if: github.event_name == 'pull_request' && needs.ai_code_review.outputs.review_status != 'CRITICAL_ISSUE'

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Add SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 3.232.21.89 >> ~/.ssh/known_hosts

      - name: Generate NGINX Configuration (Base64)
        id: generate_config
        run: |
          # Use placeholder __DOMAIN__ for substitution with the sanitized branch name on the remote server.
          # We revert to standard NGINX variable usage here, as the Base64 method avoids character corruption.
          NGINX_CONF="server {
              listen 80;
              server_name __DOMAIN__;
              return 301 https://\$host\$request_uri;
          }
          server {
              listen 443 ssl http2;
              server_name __DOMAIN__;
              ssl_certificate /etc/letsencrypt/live/__DOMAIN__/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/__DOMAIN__/privkey.pem;
              ssl_session_cache shared:SSL:10m;
              ssl_session_timeout 10m;
              location / {
                  proxy_pass http://127.0.0.1:__PORT__;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }
          }"

          
          BASE64_CONF=$(echo "$NGINX_CONF" | base64 -w 0)
          echo "NGINX_BASE64=$BASE64_CONF" >> "$GITHUB_OUTPUT"
          
          # Temporary HTTP config also uses __DOMAIN__
          TEMP_CONF="server {
              listen 80;
              server_name __DOMAIN__;
              root /var/www/letsencrypt;
          }"
          TEMP_BASE64=$(echo "$TEMP_CONF" | base64 -w 0)
          echo "TEMP_BASE64=$TEMP_BASE64" >> "$GITHUB_OUTPUT"


      - name: Deploy branch via Docker
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          NGINX_BASE64: ${{ steps.generate_config.outputs.NGINX_BASE64 }}
          TEMP_BASE64: ${{ steps.generate_config.outputs.TEMP_BASE64 }}
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 "BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF##refs/heads/}} PAT_TOKEN=${PAT_TOKEN} NGINX_BASE64='${NGINX_BASE64}' TEMP_BASE64='${TEMP_BASE64}' bash -s" <<'ENDSSH'
            set -euo pipefail

            if [ -z "$PAT_TOKEN" ]; then
              echo "âŒ PAT_TOKEN not set. Aborting."
              exit 1
            fi

            # --- SANITIZATION AND VAR DEFINITION ---
            SAFE_BRANCH=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9.-]/-/g')
            DOMAIN="$SAFE_BRANCH.debugwithian.com"
            TMPDIR="/tmp/$SAFE_BRANCH"
            PORT=""
            # ---------------------------------------

            # Find a free port
            for p in {8090..8500}; do
              if ! sudo lsof -iTCP:$p -sTCP:LISTEN >/dev/null; then
                PORT=$p
                break
              fi
            done

            if [ -z "$PORT" ]; then
              echo "âŒ No free port found"
              exit 1
            fi

            rm -rf "$TMPDIR"
            git clone --depth 1 --branch "$BRANCH" "https://$PAT_TOKEN@github.com/debugwithian/debugwithian.github.io.git" "$TMPDIR"

            # Ensure Dockerfile exists
            if [ ! -f "$TMPDIR/Dockerfile" ]; then
              printf '%s\n' \
                'FROM node:20-alpine' \
                'WORKDIR /app' \
                'COPY . .' \
                'RUN npm install --production || true' \
                'EXPOSE 3000' \
                'CMD ["node", "server.js"]' > "$TMPDIR/Dockerfile"
            fi

            docker build -t "debugwithian/preview:latest" "$TMPDIR" || true
            sudo docker rm -f "container-$SAFE_BRANCH" 2>/dev/null || true
            sudo docker run -d --name "container-$SAFE_BRANCH" -p "$PORT":3000 "debugwithian/preview:latest"

            NGINX_FILE="/etc/nginx/sites-available/$SAFE_BRANCH.conf"
            TEMP_NGINX="/etc/nginx/sites-available/$SAFE_BRANCH-temp.conf"
            WWW_LETSENCRYPT="/var/www/letsencrypt"
            sudo mkdir -p "$WWW_LETSENCRYPT" && sudo chmod 755 "$WWW_LETSENCRYPT"

            # Temporary HTTP config: DECODE, SUBSTITUTE DOMAIN, and WRITE
            echo "$TEMP_BASE64" | base64 -d | sed "s|__DOMAIN__|$DOMAIN|g" | sudo tee "$TEMP_NGINX" >/dev/null

            sudo ln -sf "$TEMP_NGINX" /etc/nginx/sites-enabled/
            sudo nginx -t
            sudo systemctl restart nginx

            # SSL request
            if host "$DOMAIN" >/dev/null 2>&1; then
              if [ ! -d "/etc/letsencrypt/live/$DOMAIN" ]; then
                sudo systemctl stop nginx
                sudo certbot certonly --standalone --non-interactive --agree-tos -m ddiamanterbitwilio@gmail.com -d "$DOMAIN" || true
                sudo systemctl start nginx
              fi
            fi
            
            # Final HTTPS config: DECODE, SUBSTITUTE PORT, SUBSTITUTE DOMAIN, and WRITE
            echo "$NGINX_BASE64" | base64 -d | sed "s|__PORT__|$PORT|g" | sed "s|__DOMAIN__|$DOMAIN|g" | sudo tee "$NGINX_FILE" >/dev/null

            sudo ln -sf "$NGINX_FILE" /etc/nginx/sites-enabled/
            
            # --- BEGIN DEBUGGING ---
            echo "--- BEGIN NGINX CONFIG $NGINX_FILE ---"
            sudo cat "$NGINX_FILE"
            echo "--- END NGINX CONFIG ---"

            # 1. Temporarily comment out problematic lines before testing
            # This is the necessary workaround for NGINX test failures on uninitialized variables.
            echo "Attempting NGINX test by temporarily removing problematic headers..."
            sudo sed -i '/proxy_set_header Host/d' "$NGINX_FILE"
            sudo sed -i '/proxy_set_header X-Real-IP/d' "$NGINX_FILE"
            sudo sed -i '/proxy_set_header X-Forwarded-For/d' "$NGINX_FILE"
            sudo sed -i '/proxy_set_header X-Forwarded-Proto/d' "$NGINX_FILE"
            
            # 2. Re-run NGINX test with minimal config
            sudo nginx -t

            # 3. If test passes, restore the original, full config and reload
            # We re-decode and re-write the complete, correct file here.
            echo "Test passed. Restoring full NGINX configuration and reloading..."
            echo "$NGINX_BASE64" | base64 -d | sed "s|__PORT__|$PORT|g" | sed "s|__DOMAIN__|$DOMAIN|g" | sudo tee "$NGINX_FILE" >/dev/null
            sudo systemctl reload nginx

            echo "âœ… Docker preview for $SAFE_BRANCH deployed at https://$DOMAIN (Docker port $PORT)"
          ENDSSH

  deploy:
    name: ðŸš€ Deploy to AWS (prod_v2)
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/prod_v2'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Add SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 3.232.21.89 >> ~/.ssh/known_hosts

      - name: Deploy and restart app on AWS (PM2)
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 '
            set -e
            cd /home/ubuntu
            git fetch origin prod_v2
            git reset --hard origin/prod_v2
            npm install
            pm2 restart all
            pm2 save
            echo "âœ… Production deployment completed successfully"
          '

      - name: Detect merged PR branches
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          # Get up to 5 most recently merged PRs into prod_v2
          MERGED_BRANCHES=$(curl -s -H "Authorization: token $PAT_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/pulls?state=closed&base=prod_v2&sort=updated&direction=desc&per_page=5" \
            | jq -r '.[] | select(.merged_at != null) | .head.ref')

          if [ -z "$MERGED_BRANCHES" ]; then
            echo "No merged PR branches found. Exiting cleanup."
            exit 0
          fi

          # Convert newlines to spaces for GitHub Actions environment variable
          MERGED_BRANCHES=$(echo "$MERGED_BRANCHES" | tr '\n' ' ')

          echo "Merged branches to clean up: $MERGED_BRANCHES"
          echo "MERGED_BRANCHES=$MERGED_BRANCHES" >> $GITHUB_ENV

      - name: Cleanup preview environments for merged branches
        env:
          MERGED_BRANCHES: ${{ env.MERGED_BRANCHES }}
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 "bash -s" <<'ENDSSH'
          set -euo pipefail

          # Ensure MERGED_BRANCHES is set
          MERGED_BRANCHES="${MERGED_BRANCHES:-}"

          # Deduplicate merged branches
          PROCESSED=()
          for BRANCH in $(echo "$MERGED_BRANCHES" | tr ' ' '\n' | sort -u); do
            SAFE_BRANCH="${BRANCH//[^a-zA-Z0-9.-]/-}"  # sanitize branch name

            # Skip if already processed
            if [[ " ${PROCESSED[*]} " == *" $SAFE_BRANCH "* ]]; then
              continue
            fi
            PROCESSED+=("$SAFE_BRANCH")

            CONTAINER_NAME="container-$SAFE_BRANCH"
            NGINX_CONF="/etc/nginx/sites-available/$SAFE_BRANCH.conf"
            NGINX_ENABLED="/etc/nginx/sites-enabled/$SAFE_BRANCH.conf"
            TMPDIR="/tmp/$SAFE_BRANCH"

            echo "Cleaning preview environment for branch: $BRANCH"

            # Stop and remove Docker container if exists
            if sudo docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME\$"; then
              echo "Stopping and removing Docker container: $CONTAINER_NAME"
              sudo docker rm -f "$CONTAINER_NAME"
            fi

            # Remove Docker image if exists
            IMAGE_NAME="debugwithian/preview:latest"
            if sudo docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "^$IMAGE_NAME\$"; then
              echo "Removing Docker image: $IMAGE_NAME"
              sudo docker rmi -f "$IMAGE_NAME" || true
            fi

            # Remove NGINX config if exists
            if [ -f "$NGINX_CONF" ]; then
              echo "Removing NGINX config: $NGINX_CONF"
              sudo rm -f "$NGINX_CONF"
            fi

            # Remove symlink in sites-enabled if exists
            if [ -L "$NGINX_ENABLED" ]; then
              echo "Removing NGINX symlink: $NGINX_ENABLED"
              sudo rm -f "$NGINX_ENABLED"
            fi

            # Remove temp folder if exists
            if [ -d "$TMPDIR" ]; then
              echo "Removing temp folder: $TMPDIR"
              sudo rm -rf "$TMPDIR"
            fi
          done

          # Extra step: remove any broken symlinks in sites-enabled
          BROKEN_LINKS=$(find /etc/nginx/sites-enabled/ -xtype l)
          if [ -n "$BROKEN_LINKS" ]; then
            echo "Removing broken NGINX symlinks:"
            echo "$BROKEN_LINKS"
            sudo rm -f $BROKEN_LINKS
          fi

          # Reload NGINX safely after all removals
          if sudo nginx -t; then
            sudo systemctl reload nginx
            echo "âœ… All merged preview environments cleaned up and NGINX reloaded."
          else
            echo "âš ï¸ NGINX configuration test failed. Please check manually."
            exit 1
          fi
          ENDSSH

