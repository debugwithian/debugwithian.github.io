name: ðŸš€ Auto Deploy to AWS with AI Code Review (Groq)

on:
  pull_request:
    branches:
      - prod_v2
    types:
      - opened
      - synchronize
      - reopened
  push:
    branches:
      - prod_v2
  workflow_dispatch:

jobs:
  ai_code_review:
    name: ðŸ¤– AI Code Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    outputs:
      review_status: ${{ steps.set_review_status.outputs.review_status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Validate secrets
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          : "${GROQ_API_KEY:?GROQ_API_KEY is not set}"
          : "${PAT_TOKEN:?PAT_TOKEN is not set}"
          echo "âœ… Secrets validated."

      - name: Generate Git Diff for PR branch
        id: generate_diff
        run: |
          set -euo pipefail
          git fetch origin prod_v2
          git fetch origin +refs/pull/${{ github.event.pull_request.number }}/head:pr_branch
          git checkout pr_branch
          BASE=$(git merge-base HEAD origin/prod_v2)

          if ! git diff $BASE HEAD --quiet; then
            git diff $BASE HEAD > diff.txt
            echo "diff_exists=true" >> $GITHUB_OUTPUT
          else
            echo '{"status":"PASSED","content":"âœ… No issues detected."}' > ai_review_output.txt
            echo "diff_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Run AI Code Review (Groq)
        if: steps.generate_diff.outputs.diff_exists == 'true'
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          set -euo pipefail
          DIFF=$(<diff.txt)

          PAYLOAD=$(jq -n --arg diff "$DIFF" '{
            model: "llama-3.1-8b-instant",
            messages: [
              {
                role: "system",
                content: "You are a senior software engineer performing a strict code review. Return ONLY a single valid JSON object: {\"status\": \"CRITICAL_ISSUE|IMPROVEMENTS|PASSED\", \"content\": \"Markdown PR comment\"}. Format all code snippets with triple backticks and language hints (```html, ```js), use actual newlines, escape quotes properly, and include headings, bullet points, and preformatted code blocks. Do not return text outside JSON. Output MUST always be valid JSON."
              },
              {
                role: "user",
                content: ("Review the following git diff for potential problems (logic, syntax, style, performance, security). Return only one of: CRITICAL_ISSUE if critical issues exist, IMPROVEMENTS if suggestions, or PASSED if no issues. Format your response in GitHub Markdown with headings, bullets, and preformatted code blocks.\n\n" + $diff)
              }
            ]
          }')

          RAW_RESPONSE=$(curl -sS --fail https://api.groq.com/openai/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $GROQ_API_KEY" \
            --data-raw "$PAYLOAD") || exit 1

          REVIEW_RAW=$(echo "$RAW_RESPONSE" | jq -r '.choices[0].message.content // empty')

          # Remove any accidental ```json fences
          REVIEW_RAW=$(printf "%s" "$REVIEW_RAW" | sed -E 's/```json//g;s/```//g')

          if [ -z "$REVIEW_RAW" ]; then
            REVIEW_RAW='{"status":"PASSED","content":"âœ… No issues detected."}'
          fi

          echo "$REVIEW_RAW" | tee ai_review_output.txt

        - name: Analyze AI Review
          id: set_review_status
          run: |
            set -euo pipefail
            REVIEW_FILE="ai_review_output.txt"
            RAW=$(<"$REVIEW_FILE")

            echo "ðŸ”¹ Raw AI output:"
            echo "$RAW"
            echo "----------------------------------------"

            ###########################################################################
            # 1. Parse JSON safely
            ###########################################################################
            if jq -e . >/dev/null 2>&1 <<<"$RAW"; then
                DETECTED_STATUS=$(jq -r '.status // "IMPROVEMENTS"' <<<"$RAW")
                EXTRACTED_BODY=$(jq -r '.content // ""' <<<"$RAW")
                echo "âœ… Parsed valid JSON from AI output."
            else
                echo "âš ï¸ AI output is not valid JSON. Attempting to extract first JSON object..."
                INNER_JSON=$(echo "$RAW" | tr -d '\r\n' | grep -o '{[^}]*}' | head -n1 || true)
                if [ -n "$INNER_JSON" ]; then
                    DETECTED_STATUS=$(jq -r '.status // "IMPROVEMENTS"' <<<"$INNER_JSON")
                    EXTRACTED_BODY=$(jq -r '.content // ""' <<<"$INNER_JSON")
                    echo "âœ… Extracted JSON object from raw AI output."
                else
                    DETECTED_STATUS="PASSED"
                    EXTRACTED_BODY="$RAW"
                    echo "âš ï¸ No JSON found, defaulting to PASSED."
                fi
            fi

            echo "ðŸ”¹ Detected Status: $DETECTED_STATUS"
            echo "ðŸ”¹ Extracted Content Preview:"
            echo "$EXTRACTED_BODY" | head -n 10
            echo "----------------------------------------"

            ###########################################################################
            # 2. Remove any leftover nested JSON objects (line-by-line)
            ###########################################################################
            EXTRACTED_BODY=$(echo "$EXTRACTED_BODY" | awk '
              BEGIN { in_json=0 }
              /^\s*\{/ { in_json=1; next }
              /^\s*\}/ { in_json=0; next }
              in_json==0 { print }
            ')
            echo "ðŸ”¹ Content after removing nested JSON:"
            echo "$EXTRACTED_BODY" | head -n 10
            echo "----------------------------------------"

            ###########################################################################
            # 3. Normalize status
            ###########################################################################
            case "$DETECTED_STATUS" in
              CRITICAL* ) NORMALIZED="CRITICAL_ISSUE" ;;
              IMPROVEMENTS ) NORMALIZED="IMPROVEMENTS" ;;
              PASSED ) NORMALIZED="PASSED" ;;
              * ) NORMALIZED="IMPROVEMENTS" ;;
            esac
            echo "ðŸ”¹ Normalized Status: $NORMALIZED"
            echo "----------------------------------------"

            ###########################################################################
            # 4. Save cleaned JSON back to file (for internal reference)
            ###########################################################################
            SAFE_BODY=$(printf "%s" "$EXTRACTED_BODY" | jq -Rs '.')
            printf '{"status":"%s","content":%s}\n' "$NORMALIZED" "$SAFE_BODY" > "$REVIEW_FILE"
            echo "âœ… Cleaned JSON saved to $REVIEW_FILE"

            ###########################################################################
            # 5. Write human-readable PR comment (ai_review_status.txt)
            ###########################################################################
            {
              echo "Status: $NORMALIZED"
              echo
              printf "%s\n" "$EXTRACTED_BODY"
            } > ai_review_status.txt
            echo "âœ… PR comment written to ai_review_status.txt"
            echo "Preview:"
            head -n 15 ai_review_status.txt
            echo "----------------------------------------"

            ###########################################################################
            # 6. Set output for later steps
            ###########################################################################
            echo "review_status=$NORMALIZED" >> $GITHUB_OUTPUT
            echo "âœ… review_status output set for workflow steps"

      - name: Post AI Review as PR Comment
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          set -euo pipefail
          COMMENT=$(<ai_review_status.txt)
          JSON_BODY=$(jq -Rs --arg text "$COMMENT" '{body: $text}')
          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO=${{ github.repository }}
          API_URL="https://api.github.com/repos/$REPO/issues/$PR_NUMBER/comments"
          curl -sS -X POST \
               -H "Authorization: token $PAT_TOKEN" \
               -H "Content-Type: application/json" \
               -d "$JSON_BODY" \
               "$API_URL"

      - name: Fail PR if Critical
        if: steps.set_review_status.outputs.review_status == 'CRITICAL_ISSUE'
        run: |
          echo "âŒ CRITICAL issues detected. Merge blocked until resolved."
          exit 1


  deploy:
    name: ðŸš€ Deploy to AWS
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/prod_v2'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Add SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H 3.232.21.89 >> ~/.ssh/known_hosts

      - name: Deploy and restart app on AWS
        run: |
          set -euo pipefail
          ssh -i ~/.ssh/id_rsa ubuntu@3.232.21.89 "
            cd /home/ubuntu &&
            git fetch origin prod_v2 &&
            git reset --hard origin/prod_v2 &&
            npm install &&
            pm2 restart all &&
            echo 'Deployment completed successfully'
          "
